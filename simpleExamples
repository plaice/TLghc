var three = 3
var index.d = #d
var index2.d1.d2 = #d1 + #d2
var id.d(X) = X
var first.d(X) = X [d <- 0]
var next.d(X)  = X [d <- #d + 1]
var prev.d(X)  = X [d <- #d - 1]
var fby.d(X,Y) = if #d < 1 then X else Y [d <- #d - 1]
var ybf.d(X,Y) = if #d > -1 then Y else X [d <- #d + 1]
var lPair.d(X) = X [d <- #d * 2]
var rPair.d(X) = X [d <- #d * 2 + 1]

var asa.d(X,Y) = first.d (X wvr.d Y)

var wvr.d(X,Y) = X [d <- T]
  where
    var T = U fby.d U [d <- T+1]
    var U = if Y then #d else next.d(U)
  end

var upon.d(X,Y) = X [d <- W]
  where
    var W = 0 fby.d (if Y then W+1 else W)
  end

var sieve.d = f
  where
    dim z <- 0
    var f = #z + 2 fby.d (f wvr.z (f % first.z /= 0))
  end

dim d0 <- 0
dim d1 <- 0
dim d2 <- 0
var X = 0 fby.d0 X+1
var Y = Y-1 ybf.d0 0

var even(X) = X % 2 == 0
var Z = X wvr.d0 even(index.d0)

var primes = sieve.d0

evalExpr index2.d0.d1 @ [d0 <- 1 .. 3, d1 <- 2 .. 4]
evalExpr X @ [d0 <- -2 .. 2]
evalExpr Y @ [d0 <- -2 .. 2]
evalExpr Z @ [d0 <- 0 .. 3]
evalExpr primes @ [d0 <- 0 .. 9]
