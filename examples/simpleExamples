fun index.d = #d
fun index2.d1.d2 = #d1 + #d2
fun first.d(X) = X [d <- 0]
fun next.d(X)  = X [d <- #d + 1]
fun prev.d(X)  = X [d <- #d - 1]
fun fby.d(X,Y) = if #d < 1 then X else prev.d(Y)
fun ybf.d(X,Y) = if #d > -1 then Y else next.d(X)
fun lPair.d(X) = X [d <- #d * 2]
fun rPair.d(X) = X [d <- #d * 2 + 1]
fun evenParent.d(X) = X [d <- #d / 2]
fun oddParent.d(X) = X [d <- #d / 2 + 1]

fun asa.d(X,Y) = first.d (X wvr.d Y)

fun wvr.d(X,Y) = X [d <- T]
  where
    var T = U fby.d U [d <- T+1]
    var U = if Y then #d else next.d(U)
  end

fun upon.d(X,Y) = X [d <- W]
  where
    var W = 0 fby.d (if Y then W+1 else W)
  end

dim d  <- 0
dim d0 <- 0
dim d1 <- 0

var X = 0 fby.d X+1
var Y = Y-1 ybf.d 0

evalExpr X @ [d <- -2 .. 2]
evalExpr Y @ [d <- -2 .. 2]
evalExpr index2.d0.d1 @ [d0 <- 1 .. 3, d1 <- 2 .. 4]
